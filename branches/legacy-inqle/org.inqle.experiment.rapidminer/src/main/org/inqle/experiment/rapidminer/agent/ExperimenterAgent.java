package org.inqle.experiment.rapidminer.agent;

import java.util.List;

import org.apache.log4j.Logger;
import org.inqle.agent.AAgent;
import org.inqle.agent.AgentInfo;
import org.inqle.core.util.RandomListChooser;
import org.inqle.data.rdf.jenabean.Persister;
import org.inqle.data.rdf.jenabean.util.JenabeanWriter;
import org.inqle.data.sampling.IDataTable;
import org.inqle.data.sampling.ISampler;
import org.inqle.data.sampling.SamplerLister;
import org.inqle.experiment.rapidminer.IExperimentResult;
import org.inqle.experiment.rapidminer.IRapidMinerExperiment;
import org.inqle.experiment.rapidminer.Learner;
import org.inqle.experiment.rapidminer.RapidMinerExperimentLister;
import org.inqle.rdf.RDF;
import org.inqle.rdf.annotations.TargetDatabaseId;
import org.inqle.rdf.annotations.TargetModelName;

import thewebsemantic.Namespace;

@TargetDatabaseId(AgentInfo.AGENT_DB)
@TargetModelName(AgentInfo.AGENT_DATAMODEL)
@Namespace(RDF.INQLE)
public class ExperimenterAgent extends AAgent {

	public static final int USE_RANDOM_SAMPLER = 0;
	public static final int USE_BASE_SAMPLER = 1;
	public static final int USE_SELECTED_SAMPLER = 2;
	
	private ISampler sampler;

	private IRapidMinerExperiment rapidMinerExperiment;
	private static Logger log = Logger.getLogger(ExperimenterAgent.class);
	private int samplerMode = USE_RANDOM_SAMPLER;
	
	public int getSamplerMode() {
		return samplerMode;
	}

	public void setSamplerMode(int samplerMode) {
		this.samplerMode = samplerMode;
	}


	
//	public void clone(ExperimenterAgent objectToClone) {
//		setSamplerMode(objectToClone.getSamplerMode());
//		setSampler(objectToClone.getSampler());
//		setRapidMinerExperiment(objectToClone.getRapidMinerExperiment());
//		super.clone(objectToClone);
//	}
//	
//	public void replicate(ExperimenterAgent objectToReplicate) {
//		clone(objectToReplicate);
//		setId(objectToReplicate.getId());
//		super.replicate(objectToReplicate);
//	}
//	
//	public ExperimenterAgent createClone() {
//		ExperimenterAgent newAgent = new ExperimenterAgent();
//		newAgent.clone(this);
//		return newAgent;
//	}
//
//	public ExperimenterAgent createReplica() {
//		ExperimenterAgent newAgent = new ExperimenterAgent();
//		newAgent.replicate(this);
//		return newAgent;
//	}

	public ISampler selectSampler() {
		if (samplerMode == USE_RANDOM_SAMPLER || sampler == null) {
			//log.info("Selecting random learning cycle...");
			return selectRandomSampler();
		}
		return sampler;
	}
	
	/**
	 * Select a random sampler.  Choose among all customized samplers.  If none
	 * exist, choose among all base (uncustomized) samplers
	 * @return
	 */
	public ISampler selectRandomSampler() {
		List<ISampler> availableSamplers = SamplerLister.listSamplers(false);
		log.info("LC.selectRandomSampler(): availableSamplers(false)=" + availableSamplers);
		if (availableSamplers==null || availableSamplers.size()==0) {
			availableSamplers = SamplerLister.listSamplers(true);
		}
		int randomIndex = RandomListChooser.chooseRandomIndex(availableSamplers.size());
		return availableSamplers.get(randomIndex);
	}
	
	private IRapidMinerExperiment selectRapidMinerExperiment(IDataTable dataTable) {
		log.info("Selecting the RapidMinerExperiment...");
		
		//if a RapidMiner experiment has been specified and if it is acceptable, use it
		if (getRapidMinerExperiment() != null) {
			if (! getRapidMinerExperiment().handlesDataTable(dataTable)) {
				log.warn("The specified sampler cannot handle the data table that was generated by the sampler.");
				return null;
			}
			return getRapidMinerExperiment();
		}
		
		List<IRapidMinerExperiment> acceptableExperiments = RapidMinerExperimentLister.listMatchingExperiments(dataTable);
		
		if (acceptableExperiments == null || acceptableExperiments.size() == 0) {
			log.warn("selectRapidMinerExperiment() finds no acceptable Experiments");
			return null;
		} else {
			log.info("Acceptable experiments include:" + acceptableExperiments);
		}
		
		//otherwise, randomly select from the list of acceptable RapidMiner experiments
		int randomIndex = RandomListChooser.chooseRandomIndex(acceptableExperiments.size());
		if (randomIndex < 0) {
			log.warn("random index from 0 to acceptableExperiments.size()-1 = " + randomIndex);
			return null;
		}
		log.info("Selected this RM Experiment: " + acceptableExperiments.get(randomIndex));
		return acceptableExperiments.get(randomIndex);
	}
	
	public void run() {
		long starttime = System.currentTimeMillis();
		Persister persister = Persister.getInstance();
		setRunning();
		log.info("Starting to run()");
		
		
		cycleCount = 0;
		//run each test until interrupted or (cycleCount >= stoppingPoint OR stopping point set to 0 or less [meaning cycle continuously])
		while ((stoppingPoint <= 0 || cycleCount < stoppingPoint) && getMode() == RUNNING) {
			long cycleStartTime = System.currentTimeMillis();
			cycleCount++;
			log.info("############### Running Cycle #" + (cycleCount) + " of " + stoppingPoint);
			
			//
			
			ISampler sampler = selectSampler();
			IDataTable resultDataTable = sampler.execute();
			log.info("Got resultDataTable=\n" + resultDataTable);
			if (resultDataTable == null) {
				log.warn("Sampler " + sampler + " of class " + sampler.getClass() + " was unable" +
						" to retrieve a DataTable of results.");
				continue;
			}
			
			IRapidMinerExperiment rapidMinerExperiment = selectRapidMinerExperiment(resultDataTable);
			
			IExperimentResult experimentResult = Learner.execute(resultDataTable, rapidMinerExperiment);
			if (experimentResult == null) {
				log.warn("Resulting ExperimentResult is null.  Skip to next cycle.");
				continue;
			}
			experimentResult.setSamplerClassName(sampler.getClass().getName());
			log.info("Storing experiment result: " + JenabeanWriter.toString(experimentResult));
//			log.info("Storing experiment result");
			persister.persist(experimentResult);
			double cycleTime = (System.currentTimeMillis() - cycleStartTime) / 1000;
			log.info("Cycle # " + cycleCount + ": completed in " + cycleTime + " seconds.");
			
			if (sampler.isFinishedSamplingStrategy()) break;
		}
		long stoptime = System.currentTimeMillis();
		double runseconds = (stoptime - starttime) / 1000;
		log.info("Exiting.  Completed " + cycleCount + " cycles, in " + runseconds + " seconds." +
				"  Average time per cycle is " + (runseconds / cycleCount) + " seconds.");
		setStopped();
		
	}

	public void setRapidMinerExperiment(IRapidMinerExperiment rapidMinerExperiment) {
		this.rapidMinerExperiment = rapidMinerExperiment;
	}

	public IRapidMinerExperiment getRapidMinerExperiment() {
		return rapidMinerExperiment;
	}
	
	public ISampler getSampler() {
		return sampler;
	}

	public void setSampler(ISampler sampler) {
		this.sampler = sampler;
	}
}